#lang racket/base
;;; Autogenerated on 2023-10-07T16:04:06
;;; DO NOT EDIT

(require (only-in
          "base.rkt"
          fx?
          fxvector?
          fxvector
          make-fxvector
          fxvector-ref
          fxvector-set!
          fxvector-length
          fxvector->list
          list->fxvector)
         (only-in "../128.rkt" comparator? make-comparator)
         racket/contract
         racket/unsafe/ops)

(provide (all-from-out "base.rkt")
         fxvector-append-subvectors
         (contract-out
          (fxvector-unfold
           (-> procedure? exact-nonnegative-integer? any/c fxvector?))
          (fxvector-unfold-right
           (-> procedure? exact-nonnegative-integer? any/c fxvector?))
          (fxvector-copy
           (->*
            (fxvector?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            fxvector?))
          (fxvector-copy!
           (->*
            (fxvector? exact-nonnegative-integer? fxvector?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            void?))
          (fxvector-reverse-copy
           (->*
            (fxvector?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            fxvector?))
          (fxvector-reverse-copy!
           (->*
            (fxvector? exact-nonnegative-integer? fxvector?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            void?))
          (fxvector-append (-> fxvector? ... fxvector?))
          (fxvector-concatenate (-> (listof fxvector?) fxvector?))
          (fxvector-empty? (-> fxvector? boolean?))
          (fxvector= (-> fxvector? fxvector? fxvector? ... boolean?))
          (fxvector-take (-> fxvector? exact-nonnegative-integer? fxvector?))
          (fxvector-take-right
           (-> fxvector? exact-nonnegative-integer? fxvector?))
          (fxvector-drop (-> fxvector? exact-nonnegative-integer? fxvector?))
          (fxvector-drop-right
           (-> fxvector? exact-nonnegative-integer? fxvector?))
          (fxvector-segment
           (-> fxvector? exact-positive-integer? (listof fxvector?)))
          (fxvector-fold
           (->i
            ((kons
              (vecs)
              (and/c
               (unconstrained-domain-> any/c)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 2)))))
             (knil any/c)
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ any/c)))
          (fxvector-fold-right
           (->i
            ((kons
              (vecs)
              (and/c
               (unconstrained-domain-> any/c)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 2)))))
             (knil any/c)
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ any/c)))
          (fxvector-map
           (->i
            ((proc
              (vecs)
              (and/c
               (unconstrained-domain-> fx?)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ fxvector?)))
          (fxvector-map!
           (->i
            ((proc
              (vecs)
              (and/c
               (unconstrained-domain-> fx?)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ fxvector?)))
          (fxvector-for-each
           (->i
            ((proc
              (vecs)
              (lambda (f)
                (and (procedure? f)
                     (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ void?)))
          (fxvector-count
           (->i
            ((proc
              (vecs)
              (and/c
               (unconstrained-domain-> any/c)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ exact-nonnegative-integer?)))
          (fxvector-cumulate (-> (-> any/c fx? fx?) any/c fxvector? fxvector?))
          (fxvector-take-while (-> (-> fx? any/c) fxvector? fxvector?))
          (fxvector-take-while-right (-> (-> fx? any/c) fxvector? fxvector?))
          (fxvector-drop-while (-> (-> fx? any/c) fxvector? fxvector?))
          (fxvector-drop-while-right (-> (-> fx? any/c) fxvector? fxvector?))
          (fxvector-index
           (->i
            ((proc
              (vecs)
              (and/c
               (unconstrained-domain-> any/c)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ (or/c exact-nonnegative-integer? #f))))
          (fxvector-index-right
           (->i
            ((proc
              (vecs)
              (and/c
               (unconstrained-domain-> any/c)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ (or/c exact-nonnegative-integer? #f))))
          (fxvector-skip
           (->i
            ((proc
              (vecs)
              (and/c
               (unconstrained-domain-> any/c)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ (or/c exact-nonnegative-integer? #f))))
          (fxvector-skip-right
           (->i
            ((proc
              (vecs)
              (and/c
               (unconstrained-domain-> any/c)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ (or/c exact-nonnegative-integer? #f))))
          (fxvector-any
           (->i
            ((proc
              (vecs)
              (and/c
               (unconstrained-domain-> any/c)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ any/c)))
          (fxvector-every
           (->i
            ((proc
              (vecs)
              (and/c
               (unconstrained-domain-> any/c)
               (lambda (f) (procedure-arity-includes? f (+ (length vecs) 1)))))
             (vec1 fxvector?))
            ()
            #:rest
            (vecs (listof fxvector?))
            (_ any/c)))
          (fxvector-partition
           (->
            (-> fx? any/c)
            fxvector?
            (values fxvector? exact-nonnegative-integer?)))
          (fxvector-filter (-> (-> fx? any/c) fxvector? fxvector?))
          (fxvector-remove (-> (-> fx? any/c) fxvector? fxvector?))
          (fxvector-swap!
           (->
            fxvector?
            exact-nonnegative-integer?
            exact-nonnegative-integer?
            void?))
          (fxvector-fill!
           (->*
            (fxvector? fx?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            void?))
          (fxvector-reverse!
           (->*
            (fxvector?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            void?))
          (fxvector-unfold!
           (->
            (-> exact-nonnegative-integer? any/c (values fx? any/c))
            fxvector?
            exact-nonnegative-integer?
            exact-nonnegative-integer?
            any/c
            void?))
          (fxvector-unfold-right!
           (->
            (-> exact-nonnegative-integer? any/c (values fx? any/c))
            fxvector?
            exact-nonnegative-integer?
            exact-nonnegative-integer?
            any/c
            void?))
          (reverse-fxvector->list
           (->*
            (fxvector?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            (listof fx?)))
          (reverse-list->fxvector (-> (listof fx?) fxvector?))
          (fxvector->vector
           (->*
            (fxvector?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            (vectorof fx?)))
          (vector->fxvector
           (->*
            ((vectorof fx?))
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            fxvector?))
          (make-fxvector-generator
           (->*
            (fxvector?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            (-> (or/c fx? eof-object?))))
          (write-fxvector (->* (fxvector?) (output-port?) void?))
          (fxvector-comparator comparator?)
          (in-fxvector
           (->*
            (fxvector?)
            (exact-nonnegative-integer? exact-nonnegative-integer?)
            sequence?))))

(module+
 unsafe
 (require (only-in
           (submod "base.rkt" unsafe)
           fx?
           fxvector?
           fxvector
           make-fxvector
           fxvector-ref
           fxvector-set!
           fxvector-length
           fxvector->list
           list->fxvector))
 (provide (all-from-out (submod "base.rkt" unsafe))
          fxvector-unfold
          fxvector-unfold-right
          fxvector-copy
          fxvector-copy!
          fxvector-reverse-copy
          fxvector-reverse-copy!
          fxvector-append
          fxvector-concatenate
          fxvector-empty?
          fxvector=
          fxvector-take
          fxvector-take-right
          fxvector-drop
          fxvector-drop-right
          fxvector-segment
          fxvector-fold
          fxvector-fold-right
          fxvector-map
          fxvector-map!
          fxvector-for-each
          fxvector-count
          fxvector-cumulate
          fxvector-take-while
          fxvector-take-while-right
          fxvector-drop-while
          fxvector-drop-while-right
          fxvector-index
          fxvector-index-right
          fxvector-skip
          fxvector-skip-right
          fxvector-any
          fxvector-every
          fxvector-partition
          fxvector-filter
          fxvector-remove
          fxvector-swap!
          fxvector-fill!
          fxvector-reverse!
          fxvector-unfold!
          fxvector-unfold-right!
          reverse-fxvector->list
          fxvector->vector
          make-fxvector-generator
          write-fxvector
          fxvector-comparator
          fxvector-append-subvectors
          in-fxvector))

(define (fxvector-unfold f len seed)
  (let ((v (make-fxvector len)))
    (let loop ((i 0) (state seed))
      (unless (= i len)
        (let-values (((value newstate) (f i state)))
          (unsafe-fxvector-set! v i value)
          (loop (+ i 1) newstate))))
    v))

(define (fxvector-unfold-right f len seed)
  (let ((v (make-fxvector len)))
    (let loop ((i (- len 1)) (state seed))
      (unless (= i -1)
        (let-values (((value newstate) (f i state)))
          (unsafe-fxvector-set! v i value)
          (loop (- i 1) newstate))))
    v))

(define (fxvector-copy vec (start 0) (end (unsafe-fxvector-length vec)))
  (let ((v (make-fxvector (- end start))))
    (fxvector-copy! v 0 vec start end)
    v))

(define (fxvector-copy!
         to
         at
         from
         (start 0)
         (end (unsafe-fxvector-length from)))
  (let loop ((at at) (i start))
    (unless (= i end)
      (fxvector-set! to at (fxvector-ref from i))
      (loop (+ at 1) (+ i 1)))))

(define (fxvector-reverse-copy vec (start 0) (end (unsafe-fxvector-length vec)))
  (let ((v (make-fxvector (- end start))))
    (fxvector-reverse-copy! v 0 vec start end)
    v))

(define (fxvector-reverse-copy!
         to
         at
         from
         (start 0)
         (end (unsafe-fxvector-length from)))
  (let loop ((at at) (i (- end 1)))
    (unless (< i start)
      (fxvector-set! to at (fxvector-ref from i))
      (loop (+ at 1) (- i 1)))))

(define (fxvector-append . vecs) (fxvector-concatenate vecs))

(define (fxvector-concatenate vecs)
  (let ((v (make-fxvector (len-sum vecs))))
    (let loop ((vecs vecs) (at 0))
      (unless (null? vecs)
        (let ((vec (car vecs)))
          (fxvector-copy! v at vec 0 (unsafe-fxvector-length vec))
          (loop (cdr vecs) (+ at (unsafe-fxvector-length vec)))))
      v)))

(define (len-sum vecs)
  (if (null? vecs)
    0
    (+ (unsafe-fxvector-length (car vecs)) (len-sum (cdr vecs)))))

(define (fxvector-append-subvectors . args)
  (let ((v (make-fxvector (len-subsum args))))
    (let loop ((args args) (at 0))
      (unless (null? args)
        (let ((vec (car args)) (start (cadr args)) (end (caddr args)))
          (fxvector-copy! v at vec start end)
          (loop (cdddr args) (+ at (- end start))))))
    v))

(define (len-subsum vecs)
  (if (null? vecs)
    0
    (+ (- (caddr vecs) (cadr vecs)) (len-subsum (cdddr vecs)))))

(define (fxvector-empty? vec) (zero? (unsafe-fxvector-length vec)))

(define (fxvector= vec1 vec2 . vecs)
  (and (fxdyadic-vecs=
        vec1
        0
        (unsafe-fxvector-length vec1)
        vec2
        0
        (unsafe-fxvector-length vec2))
       (or (null? vecs)
           (null? (car vecs))
           (fxvector= vec2 (car vecs) (cdr vecs)))))

(define (fxdyadic-vecs= vec1 start1 end1 vec2 start2 end2)
  (cond
   ((not (= end1 end2)) #f)
   ((not (< start1 end1)) #t)
   ((let ((elt1 (fxvector-ref vec1 start1)) (elt2 (fxvector-ref vec2 start2)))
      (= elt1 elt2))
    (fxdyadic-vecs= vec1 (+ start1 1) end1 vec2 (+ start2 1) end2))
   (else #f)))

(define (fxvector-take vec n)
  (let ((v (make-fxvector n))) (fxvector-copy! v 0 vec 0 n) v))

(define (fxvector-take-right vec n)
  (let ((v (make-fxvector n)) (len (unsafe-fxvector-length vec)))
    (fxvector-copy! v 0 vec (- len n) len)
    v))

(define (fxvector-drop vec n)
  (let* ((len (unsafe-fxvector-length vec))
         (vlen (- len n))
         (v (make-fxvector vlen)))
    (fxvector-copy! v 0 vec n len)
    v))

(define (fxvector-drop-right vec n)
  (let* ((len (unsafe-fxvector-length vec))
         (rlen (- len n))
         (v (make-fxvector rlen)))
    (fxvector-copy! v 0 vec 0 rlen)
    v))

(define (fxvector-segment vec n)
  (let loop ((r '()) (i 0) (remain (unsafe-fxvector-length vec)))
    (if (<= remain 0)
      (reverse r)
      (let ((size (min n remain)))
        (loop
         (cons (fxvector-copy vec i (+ i size)) r)
         (+ i size)
         (- remain size))))))

(define (%fxvectors-ref vecs i) (map (lambda (v) (fxvector-ref v i)) vecs))

(define (fxvector-fold kons knil vec . vecs)
  (if (null? vecs)
    (let ((len (unsafe-fxvector-length vec)))
      (let loop ((r knil) (i 0))
        (if (= i len) r (loop (kons r (unsafe-fxvector-ref vec i)) (+ i 1)))))
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs))))
      (let loop ((r knil) (i 0))
        (if (= i len)
          r
          (loop (apply kons r (%fxvectors-ref vecs i)) (+ i 1)))))))

(define (fxvector-fold-right kons knil vec . vecs)
  (if (null? vecs)
    (let ((len (unsafe-fxvector-length vec)))
      (let loop ((r knil) (i (- (unsafe-fxvector-length vec) 1)))
        (if (negative? i)
          r
          (loop (kons r (unsafe-fxvector-ref vec i)) (- i 1)))))
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs))))
      (let loop ((r knil) (i (- len 1)))
        (if (negative? i)
          r
          (loop (apply kons r (%fxvectors-ref vecs i)) (- i 1)))))))

(define (fxvector-map f vec . vecs)
  (if (null? vecs)
    (let* ((len (unsafe-fxvector-length vec)) (v (make-fxvector len)))
      (let loop ((i 0))
        (unless (= i len)
          (unsafe-fxvector-set! v i (f (unsafe-fxvector-ref vec i)))
          (loop (+ i 1))))
      v)
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs)))
           (v (make-fxvector len)))
      (let loop ((i 0))
        (unless (= i len)
          (fxvector-set! v i (apply f (%fxvectors-ref vecs i)))
          (loop (+ i 1))))
      v)))

(define (fxvector-map! f vec . vecs)
  (if (null? vecs)
    (let ((len (unsafe-fxvector-length vec)))
      (let loop ((i 0))
        (unless (= i len)
          (unsafe-fxvector-set! vec i (f (unsafe-fxvector-ref vec i)))
          (loop (+ i 1)))))
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs))))
      (let loop ((i 0))
        (unless (= i len)
          (fxvector-set! vec i (apply f (%fxvectors-ref vecs i)))
          (loop (+ i 1)))))))

(define (fxvector-for-each f vec . vecs)
  (if (null? vecs)
    (let ((len (unsafe-fxvector-length vec)))
      (let loop ((i 0))
        (unless (= i len) (f (unsafe-fxvector-ref vec i)) (loop (+ i 1)))))
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs))))
      (let loop ((i 0))
        (unless (= i len) (apply f (%fxvectors-ref vecs i)) (loop (+ i 1)))))))

(define (fxvector-count pred vec . vecs)
  (if (null? vecs)
    (let ((len (unsafe-fxvector-length vec)))
      (let loop ((i 0) (r 0))
        (cond
         ((= i (unsafe-fxvector-length vec)) r)
         ((pred (unsafe-fxvector-ref vec i)) (loop (+ i 1) (+ r 1)))
         (else (loop (+ i 1) r)))))
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs))))
      (let loop ((i 0) (r 0))
        (cond
         ((= i len) r)
         ((apply pred (%fxvectors-ref vecs i)) (loop (+ i 1) (+ r 1)))
         (else (loop (+ i 1) r)))))))

(define (fxvector-cumulate f knil vec)
  (let* ((len (unsafe-fxvector-length vec)) (v (make-fxvector len)))
    (let loop ((r knil) (i 0))
      (unless (= i len)
        (let ((next (f r (unsafe-fxvector-ref vec i))))
          (unsafe-fxvector-set! v i next)
          (loop next (+ i 1)))))
    v))

(define (fxvector-take-while pred vec)
  (let* ((len (unsafe-fxvector-length vec))
         (idx (fxvector-skip pred vec))
         (idx* (if idx idx len)))
    (fxvector-copy vec 0 idx*)))

(define (fxvector-take-while-right pred vec)
  (let* ((len (unsafe-fxvector-length vec))
         (idx (fxvector-skip-right pred vec))
         (idx* (if idx (+ idx 1) 0)))
    (fxvector-copy vec idx* len)))

(define (fxvector-drop-while pred vec)
  (let* ((len (unsafe-fxvector-length vec))
         (idx (fxvector-skip pred vec))
         (idx* (if idx idx len)))
    (fxvector-copy vec idx* len)))

(define (fxvector-drop-while-right pred vec)
  (let* ((len (unsafe-fxvector-length vec))
         (idx (fxvector-skip-right pred vec))
         (idx* (if idx idx -1)))
    (fxvector-copy vec 0 (+ 1 idx*))))

(define (fxvector-index pred vec . vecs)
  (if (null? vecs)
    (let ((len (unsafe-fxvector-length vec)))
      (let loop ((i 0))
        (cond
         ((= i len) #f)
         ((pred (unsafe-fxvector-ref vec i)) i)
         (else (loop (+ i 1))))))
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs))))
      (let loop ((i 0))
        (cond
         ((= i len) #f)
         ((apply pred (%fxvectors-ref vecs i)) i)
         (else (loop (+ i 1))))))))

(define (fxvector-index-right pred vec . vecs)
  (if (null? vecs)
    (let ((len (unsafe-fxvector-length vec)))
      (let loop ((i (- len 1)))
        (cond
         ((negative? i) #f)
         ((pred (unsafe-fxvector-ref vec i)) i)
         (else (loop (- i 1))))))
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs))))
      (let loop ((i (- len 1)))
        (cond
         ((negative? i) #f)
         ((apply pred (%fxvectors-ref vecs i)) i)
         (else (loop (- i 1))))))))

(define (fxvector-skip pred vec . vecs)
  (if (null? vecs)
    (fxvector-index (lambda (x) (not (pred x))) vec)
    (apply fxvector-index (lambda xs (not (apply pred xs))) vec vecs)))

(define (fxvector-skip-right pred vec . vecs)
  (if (null? vecs)
    (fxvector-index-right (lambda (x) (not (pred x))) vec)
    (apply fxvector-index-right (lambda xs (not (apply pred xs))) vec vecs)))

(define (fxvector-any pred vec . vecs)
  (if (null? vecs)
    (let ((len (unsafe-fxvector-length vec)))
      (let loop ((i 0))
        (cond
         ((= i len) #f)
         ((pred (unsafe-fxvector-ref vec i)))
         (else (loop (+ i 1))))))
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs))))
      (let loop ((i 0))
        (cond
         ((= i len) #f)
         ((apply pred (%fxvectors-ref vecs i)))
         (else (loop (+ i 1))))))))

(define (fxvector-every pred vec . vecs)
  (if (null? vecs)
    (let ((len (unsafe-fxvector-length vec)))
      (let loop ((i 0) (last #t))
        (cond
         ((= i len) last)
         ((pred (unsafe-fxvector-ref vec i)) => (lambda (r) (loop (+ i 1) r)))
         (else #f))))
    (let* ((vecs (cons vec vecs))
           (len (apply min (map unsafe-fxvector-length vecs))))
      (let loop ((i 0) (last #t))
        (cond
         ((= i len) last)
         ((apply pred (%fxvectors-ref vecs i)) => (lambda (r) (loop (+ i 1) r)))
         (else #f))))))

(define (fxvector-partition pred vec)
  (let* ((len (unsafe-fxvector-length vec))
         (cnt (fxvector-count pred vec))
         (r (make-fxvector len)))
    (let loop ((i 0) (yes 0) (no cnt))
      (cond
       ((= i len) (values r cnt))
       ((pred (unsafe-fxvector-ref vec i))
        (unsafe-fxvector-set! r yes (unsafe-fxvector-ref vec i))
        (loop (+ i 1) (+ yes 1) no))
       (else
        (unsafe-fxvector-set! r no (unsafe-fxvector-ref vec i))
        (loop (+ i 1) yes (+ no 1)))))))

(define (fxvector-filter pred vec)
  (let* ((len (unsafe-fxvector-length vec))
         (cnt (fxvector-count pred vec))
         (r (make-fxvector cnt)))
    (let loop ((i 0) (j 0))
      (cond
       ((= i len) r)
       ((pred (unsafe-fxvector-ref vec i))
        (unsafe-fxvector-set! r j (unsafe-fxvector-ref vec i))
        (loop (+ i 1) (+ j 1)))
       (else (loop (+ i 1) j))))))

(define (fxvector-remove pred vec)
  (fxvector-filter (lambda (x) (not (pred x))) vec))

(define (fxvector-swap! vec i j)
  (let ((ival (fxvector-ref vec i)) (jval (fxvector-ref vec j)))
    (fxvector-set! vec i jval)
    (fxvector-set! vec j ival)))

(define (fxvector-fill! vec fill (start 0) (end (unsafe-fxvector-length vec)))
  (unless (= start end)
    (fxvector-set! vec start fill)
    (fxvector-fill! vec fill (+ start 1) end)))

(define (fxvector-reverse! vec (start 0) (end (unsafe-fxvector-length vec)))
  (let loop ((i start) (j (- end 1)))
    (when (< i j) (fxvector-swap! vec i j) (loop (+ i 1) (- j 1)))))

(define (fxvector-unfold! f vec start end seed)
  (let loop ((i start) (seed seed))
    (when (< i end)
      (let-values (((elt seed) (f i seed)))
        (fxvector-set! vec i elt)
        (loop (+ i 1) seed)))))

(define (fxvector-unfold-right! f vec start end seed)
  (let loop ((i (- end 1)) (seed seed))
    (when (>= i start)
      (let-values (((elt seed) (f i seed)))
        (fxvector-set! vec i elt)
        (loop (- i 1) seed)))))

(define (reverse-fxvector->list
         vec
         (start 0)
         (end (unsafe-fxvector-length vec)))
  (let loop ((i start) (r '()))
    (if (= i end) r (loop (+ 1 i) (cons (fxvector-ref vec i) r)))))

(define (reverse-list->fxvector list)
  (let* ((len (length list)) (r (make-fxvector len)))
    (let loop ((i 0) (list list))
      (cond
       ((= i len) r)
       (else
        (fxvector-set! r (- len i 1) (car list))
        (loop (+ i 1) (cdr list)))))))

(define (fxvector->vector vec (start 0) (end (unsafe-fxvector-length vec)))
  (let* ((len (- end start)) (r (make-vector len)))
    (let loop ((i start) (o 0))
      (cond
       ((= i end) r)
       (else (vector-set! r o (fxvector-ref vec i)) (loop (+ i 1) (+ o 1)))))))

(define (vector->fxvector vec (start 0) (end (vector-length vec)))
  (let* ((len (- end start)) (r (make-fxvector len)))
    (let loop ((i start) (o 0))
      (cond
       ((= i end) r)
       (else (fxvector-set! r o (vector-ref vec i)) (loop (+ i 1) (+ o 1)))))))

(define (make-fxvector-generator
         vec
         (start 0)
         (end (unsafe-fxvector-length vec)))
  (lambda ()
    (if (>= start end)
      eof
      (let ((next (fxvector-ref vec start))) (set! start (+ start 1)) next))))

(define (write-fxvector vec (port (current-output-port)))
  (begin
    (fprintf port "#~A(" 'fx)
    (let ((last (- (unsafe-fxvector-length vec) 1)))
      (let loop ((i 0))
        (cond
         ((= i last)
          (write (unsafe-fxvector-ref vec i) port)
          (display ")" port))
         (else
          (write (unsafe-fxvector-ref vec i) port)
          (display " " port)
          (loop (+ i 1))))))))

(define (fxvector< vec1 vec2)
  (let ((len1 (unsafe-fxvector-length vec1))
        (len2 (unsafe-fxvector-length vec2)))
    (cond
     ((< len1 len2) #t)
     ((> len1 len2) #f)
     (else
      (let loop ((i 0))
        (cond
         ((= i len1) #f)
         ((< (unsafe-fxvector-ref vec1 i) (unsafe-fxvector-ref vec2 i)) #t)
         ((> (unsafe-fxvector-ref vec1 i) (unsafe-fxvector-ref vec2 i)) #f)
         (else (loop (+ i 1)))))))))

(define (fxvector-hash vec)
  (let ((len (min 256 (unsafe-fxvector-length vec))))
    (let loop ((i 0) (r 0))
      (if (= i len)
        (abs (floor (real-part (inexact->exact r))))
        (loop (+ i 1) (+ r (unsafe-fxvector-ref vec i)))))))

(define fxvector-comparator
  (make-comparator fxvector? fxvector= fxvector< fxvector-hash))

(define (in-fxvector vec (start 0) (end (unsafe-fxvector-length vec)))
  (make-do-sequence
   (lambda ()
     (values
      (lambda (i) (fxvector-ref vec i))
      #f
      add1
      start
      (lambda (i) (< i end))
      #f
      #f))))

(module+
 test
 (require rackunit "../128.rkt")
 (define-syntax test
   (syntax-rules ()
     ((_ name expect expr) (test-equal? name expr expect))
     ((_ expect expr) (check-equal? expr expect))))
 (define-syntax test-assert
   (syntax-rules ()
     ((_ name expr) (test-not-false name expr))
     ((_ expr) (check-not-false expr))))
 (define-syntax-rule (test-group name tests ...) (begin tests ...))
 (define (times2 x) (* x 2))
 (define s5 (fxvector 1 2 3 4 5))
 (define s4 (fxvector 1 2 3 4))
 (define s5+ (fxvector 1 2 3 4 6))
 (define (steady i x) (values x x))
 (define (count-up i x) (values x (+ x 1)))
 (define (count-down i x) (values x (- x 1)))
 (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
 (define fxvector< (comparator-ordering-predicate fxvector-comparator))
 (define fxvector-hash (comparator-hash-function fxvector-comparator))
 (define g (make-fxvector-generator s5))
 (define-syntax test-equiv
   (syntax-rules ()
     ((test-equiv expect expr) (test expect (fxvector->list expr)))
     ((test-equiv name expect expr) (test name expect (fxvector->list expr)))))
 (test-group
  "@vector"
  (test-group
   "@vector/constructors"
   (test-equiv "make" '(3 3 3 3 3) (make-fxvector 5 3))
   (test-equiv "@vector" '(-2 -1 0 1 2) (fxvector -2 -1 0 1 2))
   (test-equiv "unfold up" '(10 11 12 13 14) (fxvector-unfold count-up 5 10))
   (test-equiv "unfold down" '(10 9 8 7 6) (fxvector-unfold count-down 5 10))
   (test-equiv "unfold steady" '(10 10 10 10 10) (fxvector-unfold steady 5 10))
   (test-equiv
    "unfold-right up"
    '(14 13 12 11 10)
    (fxvector-unfold-right count-up 5 10))
   (test-equiv
    "unfold-right down"
    '(6 7 8 9 10)
    (fxvector-unfold-right count-down 5 10))
   (test-equiv
    "unfold-right steady"
    '(10 10 10 10 10)
    (fxvector-unfold-right steady 5 10))
   (test-equiv "copy" '(1 2 3 4 5) (fxvector-copy s5))
   (test-assert "copy2" (not (eqv? s5 (fxvector-copy s5))))
   (test-equiv "copy3" '(2 3) (fxvector-copy s5 1 3))
   (test-equiv "reverse-copy" '(5 4 3 2 1) (fxvector-reverse-copy s5))
   (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5) (fxvector-append s5 s5))
   (test-equiv
    "concatenate"
    '(1 2 3 4 5 1 2 3 4 5)
    (fxvector-concatenate (list s5 s5)))
   (test-equiv
    "append-subvectors"
    '(2 3 2 3)
    (fxvector-append-subvectors s5 1 3 s5 1 3)))
  (test-group
   "@vector/predicates"
   (test-assert "@?" (fx? 5))
   (test-assert "@vector?" (fxvector? s5))
   (test-assert "not @vector?" (not (fxvector? #t)))
   (test-assert "empty" (fxvector-empty? (fxvector)))
   (test-assert "not empty" (not (fxvector-empty? s5)))
   (test-assert "=" (fxvector= (fxvector 1 2 3) (fxvector 1 2 3)))
   (test-assert
    "= multi"
    (fxvector= (fxvector 1 2 3) (fxvector 1 2 3) (fxvector 1 2 3)))
   (test-assert "not =" (not (fxvector= (fxvector 1 2 3) (fxvector 3 2 1))))
   (test-assert "not =2" (not (fxvector= (fxvector 1 2 3) (fxvector 1 2))))
   (test-assert
    "not = multi"
    (not (fxvector= (fxvector 1 2 3) (fxvector 1 2 3) (fxvector 3 2 1)))))
  (test-group
   "@vector/selectors"
   (test "ref" 1 (fxvector-ref (fxvector 1 2 3) 0))
   (test "length" 3 (unsafe-fxvector-length (fxvector 1 2 3))))
  (test-group
   "@vector/iteration"
   (test-equiv "take" '(1 2) (fxvector-take s5 2))
   (test-equiv "take-right" '(4 5) (fxvector-take-right s5 2))
   (test-equiv "drop" '(3 4 5) (fxvector-drop s5 2))
   (test-equiv "drop-right" '(1 2 3) (fxvector-drop-right s5 2))
   (test
    "segment"
    (list (fxvector->list (fxvector 1 2 3)) (fxvector->list (fxvector 4 5)))
    (map fxvector->list (fxvector-segment s5 3)))
   (test "fold" -6 (fxvector-fold - 0 (fxvector 1 2 3)))
   (test
    "fold"
    '(((0 1 4) 2 5) 3 6)
    (fxvector-fold list 0 (fxvector 1 2 3) (fxvector 4 5 6)))
   (test "fold-right" -6 (fxvector-fold-right - 0 (fxvector 1 2 3)))
   (test
    "fold-right"
    '(((0 3 6) 2 5) 1 4)
    (fxvector-fold-right list 0 (fxvector 1 2 3) (fxvector 4 5 6)))
   (test-equiv "map" '(-1 -2 -3 -4 -5) (fxvector-map - s5))
   (test-equiv "map" '(-2 -4 -6 -8 -10) (fxvector-map - s5 s5 s5 s5))
   (let ((v (fxvector 1 2 3 4 5)))
     (fxvector-map! - v)
     (test-equiv "map!" '(-1 -2 -3 -4 -5) v))
   (let ((v (fxvector 1 2 3 4 5)) (v2 (fxvector 6 7 8 9 10)))
     (fxvector-map! + v v2)
     (test-equiv "map!" '(7 9 11 13 15) v))
   (let ((list '()))
     (fxvector-for-each (lambda (e) (set! list (cons e list))) s5)
     (test "for-each" '(5 4 3 2 1) (cons (car list) (cdr list))))
   (let ((list '()))
     (fxvector-for-each
      (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      s5
      (fxvector 6 7 8 9 10))
     (test
      "for-each"
      '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      (cons (car list) (cdr list))))
   (test "count" 3 (fxvector-count odd? s5))
   (test "count" 2 (fxvector-count > s5 (fxvector 9 2 1 5 3)))
   (test-equiv "cumulate" '(1 3 6 10 15) (fxvector-cumulate + 0 s5)))
  (test-group
   "@vector/searching"
   (test-equiv "take-while" '(1) (fxvector-take-while odd? s5))
   (test-equiv "take-while-right" '(5) (fxvector-take-while-right odd? s5))
   (test-equiv "drop-while" '(2 3 4 5) (fxvector-drop-while odd? s5))
   (test-equiv
    "drop-while-right"
    '(1 2 3 4)
    (fxvector-drop-while-right odd? s5))
   (test-equiv "degenerate take-while" '() (fxvector-take-while inexact? s5))
   (test-equiv
    "degenerate take-while-right"
    '()
    (fxvector-take-while-right inexact? s5))
   (test-equiv
    "degenerate drop-while"
    '(1 2 3 4 5)
    (fxvector-drop-while inexact? s5))
   (test-equiv
    "degenerate drop-while-right"
    '(1 2 3 4 5)
    (fxvector-drop-while-right inexact? s5))
   (test "index" 1 (fxvector-index even? s5))
   (test "index" 2 (fxvector-index < s5 (fxvector 0 0 10 10 0)))
   (test "index-right" 3 (fxvector-index-right even? s5))
   (test "index-right" 3 (fxvector-index-right < s5 (fxvector 0 0 10 10 0)))
   (test "skip" 1 (fxvector-skip odd? s5))
   (test "skip" 2 (fxvector-skip > s5 (fxvector 0 0 10 10 0)))
   (test "skip-right" 3 (fxvector-skip-right odd? s5))
   (test "skip-right" 3 (fxvector-skip-right > s5 (fxvector 0 0 10 10 0)))
   (test "any" 4 (fxvector-any (lambda (x) (and (even? x) (* x 2))) s5))
   (test-assert "not any" (not (fxvector-any inexact? s5)))
   (test "any + 1" 2 (fxvector-any odd+1 s5))
   (test-assert "every" (fxvector-every exact? s5))
   (test-assert "not every" (not (fxvector-every odd? s5)))
   (test-assert "every + 1" (not (fxvector-every odd+1 s5)))
   (test
    "multi-any"
    10
    (fxvector-any
     (lambda (x y) (and (even? x) (even? y) (+ x y)))
     s5
     (fxvector 0 1 2 6 4)))
   (test
    "multi-any 2"
    #f
    (fxvector-any
     (lambda (x y) (and (even? x) (even? y) (+ x y)))
     s5
     (fxvector 0 1 2 5 4)))
   (test
    "multi-every"
    10
    (fxvector-every (lambda (x) (and (exact? x) (* x 2))) s5))
   (test
    "multi-every-2"
    10
    (fxvector-every (lambda (x y) (and (exact? x) (exact? y) (+ x y))) s5 s5))
   (test-assert
    "multi-not every"
    (not (fxvector-every < s5 (fxvector 10 10 10 10 0))))
   (test-equiv
    "partition"
    '(1 3 5 2 4)
    (call-with-values
     (lambda () (fxvector-partition odd? s5))
     (lambda (vec cnt) vec)))
   (test-equiv "filter" '(1 3 5) (fxvector-filter odd? s5))
   (test-equiv "remove" '(2 4) (fxvector-remove odd? s5)))
  (test-group
   "@vector/mutators"
   (let ((v (fxvector 1 2 3)))
     (fxvector-set! v 0 10)
     (test-equiv "set!" '(10 2 3) v))
   (let ((v (fxvector 1 2 3)))
     (fxvector-swap! v 0 1)
     (test-equiv "swap!" '(2 1 3) v))
   (let ((v (fxvector 1 2 3)))
     (fxvector-fill! v 2)
     (test-equiv "fill!" '(2 2 2) v))
   (let ((v (fxvector 1 2 3)))
     (fxvector-fill! v 10 0 2)
     (test-equiv "fill2!" '(10 10 3) v))
   (let ((v (fxvector 1 2 3)))
     (fxvector-reverse! v)
     (test-equiv "reverse!" '(3 2 1) v))
   (let ((v (fxvector 1 2 3)))
     (fxvector-reverse! v 1 3)
     (test-equiv "reverse2!" '(1 3 2) v))
   (let ((v (fxvector 10 20 30 40 50)))
     (fxvector-copy! v 1 s5 2 4)
     (test-equiv "copy!" '(10 3 4 40 50) v))
   (let ((v (fxvector 10 20 30 40 50)))
     (fxvector-reverse-copy! v 1 s5 2 4)
     (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
   (let ((v (fxvector 1 2 3 4 5 6 7 8)))
     (fxvector-unfold! (lambda (_ x) (values (* x 2) (* x 2))) v 1 6 -1)
     (test-equiv "vector-unfold!" '(1 -2 -4 -8 -16 -32 7 8) v))
   (let ((v (fxvector 1 2 3 4 5 6 7 8)))
     (fxvector-unfold-right! (lambda (_ x) (values (* x 2) (* x 2))) v 1 6 -1)
     (test-equiv "vector-unfold!" '(1 -32 -16 -8 -4 -2 7 8) v)))
  (test-group
   "@vector/conversion"
   (test "@vector->list 1" '(1 2 3 4 5) (fxvector->list s5))
   (test "@vector->list 2" '(2 3 4 5) (fxvector->list s5 1))
   (test "@vector->list 3" '(2 3 4) (fxvector->list s5 1 4))
   (test "@vector->vector 1" #(1 2 3 4 5) (fxvector->vector s5))
   (test "@vector->vector 2" #(2 3 4 5) (fxvector->vector s5 1))
   (test "@vector->vector 3" #(2 3 4) (fxvector->vector s5 1 4))
   (test-equiv "list->@vector" '(1 2 3 4 5) (list->fxvector '(1 2 3 4 5)))
   (test-equiv
    "reverse-list->@vector"
    '(5 4 3 2 1)
    (reverse-list->fxvector '(1 2 3 4 5)))
   (test-equiv "vector->@vector 1" '(1 2 3 4 5) (vector->fxvector #(1 2 3 4 5)))
   (test-equiv "vector->@vector 2" '(2 3 4 5) (vector->fxvector #(1 2 3 4 5) 1))
   (test-equiv
    "vector->@vector 3"
    '(2 3 4)
    (vector->fxvector #(1 2 3 4 5) 1 4)))
  (test-group
   "@vector/misc"
   (let ((port (open-output-string)))
     (write-fxvector s5 port)
     (test
      "write-@vector"
      (format "#~S(1 2 3 4 5)" 'fx)
      (get-output-string port))
     (close-output-port port))
   (test-assert "@vector< short" (fxvector< s4 s5))
   (test-assert "not @vector< short" (not (fxvector< s5 s4)))
   (test-assert "@vector< samelen" (fxvector< s5 s5+))
   (test-assert "not @vector< samelen" (not (fxvector< s5+ s5+)))
   (test-assert "@vector=" (fxvector= s5+ s5+))
   (test "@vector-hash" 15 (fxvector-hash s5))
   (test "@vector-gen 0" 1 (g))
   (test "@vector-gen 1" 2 (g))
   (test "@vector-gen 2" 3 (g))
   (test "@vector-gen 3" 4 (g))
   (test "@vector-gen 4" 5 (g))
   (test-assert (eof-object? (g))))))

