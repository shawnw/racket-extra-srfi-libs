#lang racket

;;; The reference implementation for SRFI-160 uses shell scripts and sed and
;;; stuff to generate source files from the templates. I feel about using
;;; regexps to manipulate s-expressions much the same I feel about using them
;;; with XML or JSON - there are better tools for the job. What better than
;;; Racket/Scheme for working with s-expresssions?

(require racket/date racket/symbol)

(define root-path 'up)
(define srfi-base-path (build-path root-path "srfi" "160"))
(define private-srfi-path (build-path srfi-base-path "private"))
;(define typed-srfi-base-path (build-path root-path "typed" "srfi" "160"))
;(define private-typed-path (build-path typed-srfi-base-path "private"))

(struct nvector (id member-type in-srfi-4?))

;;; One entry for each vector type
(define nvectors
  `(,(nvector "u8" 'Byte #t)
    ,(nvector "s8" 'Fixnum #t)
    ,(nvector "u16" 'Fixnum #t)
    ,(nvector "s16" 'Fixnum #t)
    ,(nvector "u32" 'Integer #t)
    ,(nvector "s32" 'Integer #t)
    ,(nvector "u64" 'Integer #t)
    ,(nvector "s64" 'Integer #t)
    ,(nvector "f32" 'Flonum #t)
    ,(nvector "f64" 'Flonum #t)
    ,(nvector "c64" 'Float-Complex #f)
    ,(nvector "c128" 'Float-Complex #f)
    ,(nvector "fl" 'FlVector #f)))

;;; Files to copy directly
(define install-files '("base.rkt"))
(define install-private-files '("complex.rkt" "valid.rkt" "flvector.rkt"))

;;; Create all needed directories and copy/generate SRFI-160 source files.
(define (main)
  (make-directory-if-not-exists srfi-base-path)
  (make-directory-if-not-exists private-srfi-path)
  ;(make-directory-if-not-exists typed-srfi-base-path)
  ;(make-directory-if-not-exists private-typed-path)
  (copy-files install-files srfi-base-path)
  (copy-files install-private-files private-srfi-path)
  (for ([nvec (in-list nvectors)])
    (make-vector2list nvec)
    (make-module nvec)))

(define (make-directory-if-not-exists dir-path)
  (unless (directory-exists? dir-path)
    (printf "Creating ~S~%" (path->string dir-path))
    (make-directory dir-path)))

(define (copy-files files dest-dir)
  (for ([file (in-list files)])
    (let ([dest-path (build-path dest-dir file)])
      (printf "Copying ~S to ~S~%" file (path->string dest-path))
      (copy-file file dest-path #t))))

(define now (date->string (current-date) 'iso-8601))

(define (preamble out #:typed [typed? #f])
  (fprintf out "#lang ~Aracket/base~%" (if typed? "typed/" ""))
  (fprintf out ";;; Autogenerated on ~A~%" now)
  (displayln ";;; DO NOT EDIT\n" out))

(define (make-module nvec)
  (let ([output-file (build-path srfi-base-path (format "~A.rkt" (nvector-id nvec)))])
    (make-source-from-template nvec "at-impl.rkt" output-file)))

(define (make-vector2list nvec)
  (let ([output-file (build-path private-srfi-path (format "~A-vector2list.rkt" (nvector-id nvec)))])
    (make-source-from-template
     nvec "at-vector2list.rkt" output-file
     #:extra-preamble
     (lambda (out)
       (pretty-write
        (process-sexp nvec
                      (if (nvector-in-srfi-4? nvec)
                          '(require (only-in ffi/vector @vector-length @vector-ref))
                          `(require (only-in ,(if (string=? (nvector-id nvec) "fl")
                                                  "flvector.rkt"
                                                  "complex.rkt") @vector-length @vector-ref))))
        out)
       (newline out)))))

(define (make-source-from-template nvec template-file output-file
                                   #:extra-preamble [extra-preamble #f])
  (printf "Creating ~S... " (path->string output-file))
  (parameterize ([pretty-print-columns 80])
    (call-with-output-file
      output-file
      #:exists 'replace
      (lambda (out)
        (call-with-input-file template-file
          (lambda (in)
            (preamble out)
            (when extra-preamble (extra-preamble out))
            (process-template nvec in out)))))
    (displayln "done")))

;;; Replace @ in symbols with the numeric vector id
;;; @vector-ref -> u8vector-ref for example
(define (process-sexp nvec sexp)
  (cond
    ((symbol? sexp)
     (let ([name (symbol->immutable-string sexp)])
       (if (regexp-match? #rx"@" name)
           (string->symbol (regexp-replace #rx"@" name (nvector-id nvec)))
           sexp)))
    ((list? sexp) ; Proper lists
     (map (lambda (elem) (process-sexp nvec elem)) sexp))
    ((pair? sexp) ; Improper lists
     (cons (process-sexp nvec (car sexp)) (process-sexp nvec (cdr sexp))))
    ((vector? sexp)
     (for/vector #:length (vector-length sexp) ([elem (in-vector sexp)]) (process-sexp nvec elem)))
    (else sexp)))

(define (process-template nvec in out)
  (for ([sexp (in-port read in)])
    (pretty-write (process-sexp nvec sexp) out)
    (newline out)))

(main)
