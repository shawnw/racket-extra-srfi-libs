#lang racket/base

;;; The reference implementation for SRFI-160 uses shell scripts and sed and
;;; stuff to generate source files from the templates. I feel about using
;;; regexps to manipulate s-expressions much the same I feel about using them
;;; with XML or JSON - there are better tools for the job. What better than
;;; Racket/Scheme for working with s-expresssions?

(require racket/date racket/pretty racket/symbol)

(define root-path 'up)
(define srfi-base-path (build-path root-path "srfi" "160"))
(define private-srfi-path (build-path srfi-base-path "private"))
;(define typed-srfi-base-path (build-path root-path "typed" "srfi" "160"))
;(define private-typed-path (build-path typed-srfi-base-path "private"))

(struct nvector (id member-type in-srfi-4? emit-tests? unsafe-available?))

;;; One entry for each vector type
(define nvectors
  `(,(nvector "u8" 'Byte #t #f #t)
    ,(nvector "s8" 'Fixnum #t #f #f)
    ,(nvector "u16" 'Fixnum #t #f #t)
    ,(nvector "s16" 'Fixnum #t #t #t)
    ,(nvector "u32" 'Integer #t #f #f)
    ,(nvector "s32" 'Integer #t #t #f)
    ,(nvector "u64" 'Integer #t #f #f)
    ,(nvector "s64" 'Integer #t #t #f)
    ,(nvector "f32" 'Flonum #t #f #f)
    ,(nvector "f64" 'Flonum #t #f #t)
    ,(nvector "c64" 'Float-Complex #f #f #f)
    ,(nvector "c128" 'Float-Complex #f #f #f)
    ,(nvector "fl" 'FlVector #f #f #t)
    ,(nvector "fx" 'FxVector #f #t #t)))

;;; Files to copy directly
(define install-files '("base.rkt"))
(define install-private-files '("complex.rkt" "valid.rkt" "flvector.rkt" "fxvector.rkt"))

(define (make-directory-if-not-exists dir-path)
  (unless (directory-exists? dir-path)
    (printf "Creating ~S~%" (path->string dir-path))
    (make-directory dir-path)))

(define (copy-files files dest-dir)
  (for ([file (in-list files)])
    (let ([dest-path (build-path dest-dir file)])
      (printf "Copying ~S to ~S~%" file (path->string dest-path))
      (copy-file file dest-path #t))))

(define now (parameterize ([date-display-format 'iso-8601]) (date->string (current-date) #t)))

(define (preamble out #:typed [typed? #f])
  (fprintf out "#lang ~Aracket/base~%" (if typed? "typed/" ""))
  (fprintf out ";;; Autogenerated on ~A~%" now)
  (displayln ";;; DO NOT EDIT\n" out))

(define (make-module nvec)
  (let ([output-file (build-path srfi-base-path (format "~A.rkt" (nvector-id nvec)))])
    (make-source-from-template nvec "at-impl.rkt" output-file #:add-tests (nvector-emit-tests? nvec))))

(define (make-vector2list nvec)
  (let ([output-file (build-path private-srfi-path (format "~A-vector2list.rkt" (nvector-id nvec)))])
    (make-source-from-template
     nvec "at-vector2list.rkt" output-file
     #:extra-preamble
     (lambda (out)
       (pretty-write
        (process-sexp nvec
                      (if (nvector-in-srfi-4? nvec)
                          '(require (only-in ffi/vector @vector-length @vector-ref))
                          `(require (only-in ,(case (nvector-id nvec)
                                                (("fl") "flvector.rkt")
                                                (("fx") "fxvector.rkt")
                                                (else "complex.rkt")) @vector-length @vector-ref))))
        out)
       (newline out)))))

(define (make-source-from-template nvec template-file output-file
                                   #:extra-preamble [extra-preamble #f]
                                   #:add-tests [add-tests? #f])
  (printf "Creating ~S... " (path->string output-file))
  (parameterize ([pretty-print-columns 80])
    (call-with-output-file
      output-file
      #:exists 'replace
      (lambda (out)
        (call-with-input-file template-file
          (lambda (in)
            (preamble out)
            (when extra-preamble (extra-preamble out))
            (process-template nvec in out)))
        (when add-tests?
          (call-with-input-file "at-test.rkt"
            (lambda (test-in)
              (process-template nvec test-in out #:in-test #t)))))))
  (displayln "done"))

;;; Replace @ in symbols with the numeric vector id
;;; @vector-ref -> u8vector-ref for example
(define (process-sexp nvec sexp #:in-test [in-test? #f])
  (define use-unsafe-ops (make-parameter #f))
  (define in-require (make-parameter #f))
  (define at-re #rx"@")
  (define (real-process-sexp sexp)
    (cond
      ((symbol? sexp)
       (let ([name (symbol->immutable-string sexp)])
         (if (regexp-match? at-re name)
             (cond
               ((and (use-unsafe-ops) ;;; Use unsafe functions where available and vetted
                     (nvector-unsafe-available? nvec)
                     (memq sexp '(@vector-ref @vector-set!)))
                (if (string=? (nvector-id nvec) "u8")
                    (string->symbol (regexp-replace #rx"@vector" name "unsafe-bytes"))
                    (string->symbol (regexp-replace at-re name (format "unsafe-~A" (nvector-id nvec))))))
               ((and (not (in-require))
                     (member (nvector-id nvec) '("u8" "fl" "fx")) ;;; Always use unsafe -length when available
                     (eq? sexp '@vector-length))
                (case (nvector-id nvec)
                  (("u8") 'unsafe-bytes-length)
                  (("fl") 'unsafe-flvector-length)
                  (("fx") 'unsafe-fxvector-length)))
               (else
                (string->symbol (regexp-replace at-re name (nvector-id nvec)))))
             sexp)))
      #|
      ;;; Work in progress for adding tests of flonum-type vectors
    ((and (list? sexp) (not (empty? sexp))) ; Proper lists
     (cond
       ((and in-test? ((listof real?) sexp))
        (map real->double-flonum sexp))
       ((and in-test?
             (memq (car sexp) '(@vector list))
             (memq (nvector-member-type nvec) '(Flonum Float-Complex))
             ((listof real?) (cdr sexp)))
        (cons (process-sexp nvec (car sexp) #:in-test in-test?)
              (map real->double-flonum (cdr sexp))))
       ((and in-test? (memq (car sexp) '(@vector-set! make-@vector @vector-fill!)))
        (list (process-sexp nvec (first sexp) #:in-test in-test?) (second sexp) (real->double-flonum (third sexp))))
    (else (map (lambda (elem) (process-sexp nvec elem #:in-test in-test?)) sexp))))
    |#
      ((list? sexp)
       (cond
         ((and (not (null? sexp)) (eq? (car sexp) 'unsafe))
          (parameterize ([use-unsafe-ops #t])
            (map real-process-sexp (cadr sexp))))
         ((and (not (null? sexp)) (eq? (car sexp) 'require))
          (parameterize ([in-require #t])
            (map real-process-sexp sexp)))
         (else
          (map real-process-sexp sexp))))
      ((pair? sexp) ; Improper lists
       (cons (real-process-sexp (car sexp)) (real-process-sexp (cdr sexp))))
      #|
      ((vector? sexp)
      (if (and in-test? (eq? (nvector-member-type nvec) 'Flonum))
      (for/vector #:length (vector-length sexp) ([elem (in-vector sexp)]) (real->double-flonum elem))
      sexp))
      |#
      (else sexp)))
  (real-process-sexp sexp))

(define (process-template nvec in out #:in-test [in-test? #f])
  (for ([sexp (in-port read in)])
    (pretty-write (process-sexp nvec sexp #:in-test in-test?) out)
    (newline out)))

;;; Create all needed directories and copy/generate SRFI-160 source files.
(make-directory-if-not-exists srfi-base-path)
(make-directory-if-not-exists private-srfi-path)
;(make-directory-if-not-exists typed-srfi-base-path)
;(make-directory-if-not-exists private-typed-path)
(copy-files install-files srfi-base-path)
(copy-files install-private-files private-srfi-path)
(for ([nvec (in-list nvectors)])
  (make-vector2list nvec)
  (make-module nvec))
